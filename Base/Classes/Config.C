/***************************************************************************
 *
 *   Copyright (C) 2006 by Willem van Straten
 *   Licensed under the Academic Free License version 2.1
 *
 ***************************************************************************/

// #define _DEBUG 1

#include "Pulsar/Config.h"

// This file is generated by configure
#include "Management/psrchive_install.h"

#include "CommandParser.h"

#include <stdlib.h>

#include <iostream>

using namespace std;

// global configuration
Configuration* Pulsar::Config::config = 0;

//
Pulsar::Config::Interface* Pulsar::Config::interface = 0;

void Pulsar::Config::load_config () try {

  config = new Configuration;

#ifdef _DEBUG
  cerr << "Pulsar::Config::load_config runtime=" << get_runtime () << endl;
#endif

  config->load (get_runtime() + "/psrchive.cfg");
  
  const char* home = getenv ("HOME");
  if (home) {
#ifdef _DEBUG
  cerr << "Pulsar::Config::load_config $HOME=" << home << endl;
#endif
    config->load ( string(home) + "/.psrchive.cfg");
  }

}
catch (Error& error) {
  // use of a configuration file is optional
}


string Pulsar::Config::get_runtime ()
{
  return get_home() + "/share";
}

string Pulsar::Config::get_home ()
{
  char* psrchive = getenv ("PSRCHIVE");
  if (psrchive)
    return psrchive;

  return PSRCHIVE_INSTALL;
}

//! Return the configuration key/value pairs
Configuration* Pulsar::Config::get_configuration ()
{
  if (!config)
    load_config ();

#ifdef _DEBUG
  cerr << "Pulsar::Config::get_configuration return " << config << endl;
#endif

  return config;
}

//! Return the text interface to the configuration parameters
Pulsar::Config::Interface* Pulsar::Config::get_interface ()
{
  if (!interface)
    interface = new Interface;

#ifdef _DEBUG
  cerr << "Pulsar::Config::get_interface return " << interface << endl;
#endif

  return interface;
}

// specialization for CommandParser classes
template<>
TextInterface::Value* Pulsar::new_interface (Option<CommandParser>* option)
{ 
  return TextInterface::new_Interpreter( option->name,
					 option->description,
					 option->value,
					 &CommandParser::empty,
					 &CommandParser::parse);
}
