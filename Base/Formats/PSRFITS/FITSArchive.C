/***************************************************************************
 *
 *   Copyright (C) 2003 by Willem van Straten
 *   Licensed under the Academic Free License version 2.1
 *
 ***************************************************************************/
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "Pulsar/FITSArchive.h"
#include "Pulsar/Integration.h"
#include "Pulsar/Profile.h"

#include "Pulsar/FITSHdrExtension.h"
#include "Pulsar/ObsExtension.h"
#include "Pulsar/ITRFExtension.h"
#include "Pulsar/CalInfoExtension.h"
#include "Pulsar/Receiver.h"
#include "Pulsar/WidebandCorrelator.h"
#include "Pulsar/DigitiserStatistics.h"
#include "Pulsar/ProcHistory.h"
#include "Pulsar/Passband.h"
#include "Pulsar/PolnCalibratorExtension.h"
#include "Pulsar/FluxCalibratorExtension.h"
#include "Pulsar/CalibratorStokes.h"
#include "Pulsar/IntegrationOrder.h"
#include "Pulsar/PeriastronOrder.h"
#include "Pulsar/BinaryPhaseOrder.h"
#include "Pulsar/BinLngAscOrder.h"
#include "Pulsar/BinLngPeriOrder.h"
#include "Pulsar/Telescope.h"

#include "psrfitsio.h"

#include "Telescope.h"
#include "strutil.h"
#include "ephio.h"

using namespace std;

//! null constructor
// //////////////////////////
// //////////////////////////


void Pulsar::FITSArchive::init ()
{
  chanbw = 0.0; 

  scale_cross_products = false;
  correct_P236_reference_epoch = false;
}

//
//
//
Pulsar::FITSArchive::FITSArchive()
{
  if (verbose == 3)
    cerr << "FITSArchive default construct" << endl;

  add_extension(new FITSHdrExtension());

  init ();
}

//
//
//
Pulsar::FITSArchive::FITSArchive (const FITSArchive& arch)
{
  if (verbose == 3)
    cerr << "FITSArchive copy construct" << endl;

  init ();
  Archive::copy (arch); // results in call to FITSArchive::copy
}

//
//
//
Pulsar::FITSArchive::~FITSArchive()
{
  if (verbose == 3)
    cerr << "FITSArchive destruct" << endl;
}

//
//
//
const Pulsar::FITSArchive&
Pulsar::FITSArchive::operator = (const FITSArchive& arch)
{
  if (verbose == 3)
    cerr << "FITSArchive assignment operator" << endl;

  Archive::copy (arch); // results in call to FITSArchive::copy
  return *this;
}

//
//
//
Pulsar::FITSArchive::FITSArchive (const Archive& arch)
{
  if (verbose == 3)
    cerr << "FITSArchive base copy construct" << endl;

  init ();
  Archive::copy (arch); // results in call to FITSArchive::copy
}

//
//
//
Pulsar::FITSArchive::FITSArchive (const Archive& arch, 
				  const vector<unsigned>& subints)
{
  if (verbose == 3)
    cerr << "FITSArchive base extraction construct" << endl;

  init ();
  FITSArchive::copy (arch, subints);
}


/*! The Integration subset can contain anywhere between none and all of
   integrations in the source Archive */
void Pulsar::FITSArchive::copy (const Archive& archive, 
				const vector<unsigned>& subints)
{
  if (verbose == 3)
    cerr << "FITSArchive::copy" << endl;

  if (this == &archive)
    return;
  
  Archive::copy (archive, subints);

  if (verbose == 3)
    cerr << "FITSArchive::copy dynamic cast call" << endl;

  const FITSArchive* farchive = dynamic_cast<const FITSArchive*>(&archive);
  if (!farchive)
    return;
  
  if (verbose == 3)
    cerr << "FITSArchive::copy another FITSArchive" << endl;
  
  chanbw = farchive->chanbw;
  scale_cross_products = farchive->scale_cross_products;
}

//! Returns a pointer to a new copy-constructed FITSArchive instance
Pulsar::FITSArchive* Pulsar::FITSArchive::clone () const
{
  if (verbose == 3)
    cerr << "FITSArchive::clone" << endl;

  return new FITSArchive (*this);
}

//! Returns a pointer to a new select copy-constructed FITSArchive instance
Pulsar::FITSArchive* 
Pulsar::FITSArchive::extract (const vector<unsigned>& subints) const
{
  if (verbose == 3)
    cerr << "FITSArchive::extract" << endl;
  return new FITSArchive (*this, subints);
}


// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
//! Read FITS header info from a file into a FITSArchive object.
//

void Pulsar::FITSArchive::load_header (const char* filename) try
{
  int status = 0;
  fitsfile* fptr = 0;
  
  // Open the data file  
  if (verbose == 3)
    cerr << "FITSArchive::load_header fits_open_file ("<< filename <<")"<<endl;
  
  fits_open_file (&fptr, filename, READONLY, &status);
  
  if (status != 0)
    throw FITSError (status, "FITSArchive::load_header", 
		     "fits_open_file(%s)", filename);

  // These Extensions must exist in order to load

  ObsExtension*     obs_ext = getadd<ObsExtension>();
  FITSHdrExtension* hdr_ext = getadd<FITSHdrExtension>();

  // Pulsar FITS header definiton version

  if (verbose == 3)
    cerr << "FITSArchive::load_header reading FITS header version" << endl;

  string tempstr;
  string dfault;

  dfault = hdr_ext->hdrver;
  psrfits_read_key (fptr, "HDRVER", &tempstr, dfault, verbose == 3);
  hdr_ext->hdrver = tempstr;
  if (sscanf (hdr_ext->hdrver.c_str(), "%d.%d", 
	      &hdr_ext->major_version, &hdr_ext->minor_version) != 2)
    throw Error (InvalidParam, "FITSARchive::load_header",
		 "could not parse header version from " + hdr_ext->hdrver);
 
  if (verbose == 3)
    cerr << "Got: Version " << tempstr << endl;
  
  // File creation date
  
  if (verbose == 3)
    cerr << "FITSArchive::load_header reading file creation date" << endl;

  dfault = hdr_ext->creation_date;
  psrfits_read_key (fptr, "DATE", &tempstr, dfault, verbose == 3);
  hdr_ext->creation_date = tempstr;

  // Name of observer
  
  if (verbose == 3)
    cerr << "FITSArchive::load_header reading observer name" << endl;

  dfault = obs_ext->observer;
  psrfits_read_key (fptr, "OBSERVER", &tempstr, dfault, verbose == 3);
  obs_ext->observer = tempstr;
  
  if (verbose == 3)
    cerr << "Got observer: " << tempstr << endl;
  
  // Project ID
  
  if (verbose == 3)
    cerr << "FITSArchive::load_header reading project ID" << endl;

  dfault = obs_ext->project_ID;
  psrfits_read_key (fptr, "PROJID", &tempstr, dfault, verbose == 3);
  obs_ext->project_ID = tempstr;

  if (verbose == 3)
    cerr << "Got PID: " << tempstr << endl;
  
  // Telescope name
    
  if (verbose == 3)
    cerr << "FITSArchive::load_header reading telescope name" << endl;

  dfault = obs_ext->telescope;
  psrfits_read_key (fptr, "TELESCOP", &tempstr, dfault, verbose == 3);
  obs_ext->telescope = stringtok (&tempstr, " ");
  
  if (verbose == 3)
    cerr << "Got telescope: " << obs_ext->telescope << endl;
  
  if ((obs_ext->telescope).length() == 1)
    set_telescope_code ( obs_ext->telescope.at(0) );
  else
    set_telescope_code ( ::Telescope::code(obs_ext->telescope.c_str()) );

  Telescope* telescope = getadd<Telescope>();
  telescope->set_coordinates (get_telescope_code());

  // Antenna ITRF coordinates

  load_ITRFExtension (fptr);

  // Receiver parameters

  load_Receiver (fptr);

  // WidebandCorrelator parameters

  load_WidebandCorrelator (fptr);

  // Figure out what kind of observation it was

  if (verbose == 3)
    cerr << "FITSArchive::load_header reading OBS_MODE" << endl;

  psrfits_read_key (fptr, "OBS_MODE", &tempstr);
  string obs_mode = tempstr;

  // Read the name of the source

  if (verbose == 3)
    cerr << "FITSArchive::load_header reading source name" << endl;

  psrfits_read_key (fptr, "SRC_NAME", &tempstr);
  set_source ( tempstr );
  
  if (obs_mode == "PSR" || obs_mode == "LEVPSR") {
    set_type ( Signal::Pulsar );
    if (verbose == 3)
      cerr << "FITSArchive::load_header using Signal::Pulsar" << endl;
  }
  else if (obs_mode == "CAL" || obs_mode == "LEVCAL")
    set_type ( Signal::PolnCal );
  else if (obs_mode == "FOF")
    set_type ( Signal::FluxCalOff );
  else if (obs_mode == "FON")
    set_type ( Signal::FluxCalOn );
  else if (obs_mode == "PCM")
    set_type ( Signal::Calibrator );
  else if (obs_mode == "SEARCH")
    set_type ( Signal::Unknown );
  else {
    if (verbose == 3)
      cerr << "FITSArchive::load_header WARNING unknown OBSTYPE = " 
	   << tempstr <<endl;
    set_type ( Signal::Unknown );
  }
  
  // Read where the telescope was pointing
  
  if (verbose == 3)
    cerr << "FITSArchive::load_header reading coordinates" << endl;

  dfault = hdr_ext->coordmode;
  psrfits_read_key (fptr, "COORD_MD", &tempstr, dfault, verbose == 3);
  hdr_ext->coordmode = tempstr;

  if (verbose == 3)
    cerr << "Got coordinate type: " << tempstr << endl;

  if (verbose == 3)
    cerr << "FITSArchive::load_header reading equinox" << endl;

  dfault = "pre version 2.8";
  psrfits_read_key (fptr, "EQUINOX", &tempstr, dfault, verbose == 3);

  if ((tempstr == dfault) || (tempstr.empty())) {

    //
    // The file was created before the EQUINOX attribute was added,
    // or was mistakenly created with a null equinox.
    //
    if (hdr_ext->coordmode == "J2000")
      hdr_ext->coordmode = "EQUAT";
    else if (hdr_ext->coordmode == "Gal")
      hdr_ext->coordmode = "GAL";

    hdr_ext->equinox = "J2000";

  }
  else {
    hdr_ext->equinox = tempstr;

    if (verbose == 3)
      cerr << "Got equinox: " << tempstr << endl;
  }

  sky_coord coord;
  
  if (hdr_ext->coordmode == "EQUAT") {

    dfault = "";

    psrfits_read_key (fptr, "STT_CRD1", &tempstr, dfault, verbose == 3);
    string hms = tempstr;
    psrfits_read_key (fptr, "STT_CRD2", &tempstr, dfault, verbose == 3);
    coord.setHMSDMS (hms.c_str(),tempstr.c_str());

  }     
  else if (hdr_ext->coordmode == "GAL") {

    double dfault = 0.0;
    double co_ord1, co_ord2;

    psrfits_read_key (fptr, "STT_CRD1", &co_ord1, dfault, verbose == 3);
    psrfits_read_key (fptr, "STT_CRD2", &co_ord2, dfault, verbose == 3);
    AnglePair temp;
    temp.setDegrees(co_ord1,co_ord2);
    coord.setGalactic(temp);

  }
  else
    if (verbose)
      cerr << "FITSArchive::load_header WARNING COORD_MD="
	   << hdr_ext->coordmode << " not implemented" << endl;
  
  set_coordinates (coord);
  
  if (get_type() != Signal::Pulsar && get_type() != Signal::Unknown)
    load_CalInfoExtension (fptr);

  // Track mode

  if (verbose == 3)
    cerr << "FITSArchive::load_header reading track mode" << endl;

  dfault = hdr_ext->trk_mode;
  psrfits_read_key (fptr, "TRK_MODE", &tempstr, dfault, verbose == 3);
  hdr_ext->trk_mode = tempstr;

  //
  // Since PSRFITS version 2.8, the UTC date and time are stored in one string
  //

  if (verbose == 3)
    cerr << "FITSArchive::load_header reading observation date" << endl;

  dfault = "pre version 2.8";
  psrfits_read_key (fptr, "DATE-OBS", &tempstr, dfault, verbose == 3);

  if ((tempstr == dfault) || (tempstr.empty())) {

    //
    // Before version 2.8, the UTC date and time were stored separately
    //

    // Read the start UT date

    if (verbose == 3)
      cerr << "FITSArchive::load_header reading start date" << endl;

    dfault = hdr_ext->stt_date;
    psrfits_read_key (fptr, "STT_DATE", &tempstr, dfault, verbose == 3);
    hdr_ext->stt_date = tempstr;
    
    // Read the start UT

    if (verbose == 3)
      cerr << "FITSArchive::load_header reading start UT" << endl;
    
    dfault = hdr_ext->stt_time;
    psrfits_read_key (fptr, "STT_TIME", &tempstr, dfault, verbose == 3);

    // strip off any fractional seconds, if present
    unsigned decimal = tempstr.find('.');
    if (decimal != string::npos)
      tempstr = tempstr.substr (0, decimal);

    hdr_ext->stt_time = tempstr;

  }
  else {

    const unsigned date_length = strlen ("YYYY-MM-DD");
    if (tempstr.length() >= date_length)
      hdr_ext->stt_date = tempstr.substr(0,date_length);
    if (tempstr.length() > date_length)
      hdr_ext->stt_time = tempstr.substr(date_length+1);

    if (verbose == 3)
      cerr << "FITSArchive::load_header DATE-0BS parsed into\n"
	" date='" << hdr_ext->stt_date << "'\n"
	" time='" << hdr_ext->stt_time << "'\n";

  }

  // /////////////////////////////////////////////////////////////////
  
  // Read start MJD  

  long day;
  long sec;
  double frac;
  
  if (verbose == 3)
    cerr << "FITSArchive::load_header reading MJDs" << endl;
  
  psrfits_read_key (fptr, "STT_IMJD", &day, (long)0, verbose == 3);
  psrfits_read_key (fptr, "STT_SMJD", &sec, (long)0, verbose == 3);
  psrfits_read_key (fptr, "STT_OFFS", &frac, 0.0, verbose == 3);
  
  hdr_ext->start_time = MJD ((int)day, (int)sec, frac);
  if (verbose == 3)
    cerr << "Got start time: " << hdr_ext->start_time.printall() << endl;

  // Read the start LST (in seconds)

  if (verbose == 3)
    cerr << "FITSArchive::load_header reading start LST" << endl;

  psrfits_read_key (fptr, "STT_LST", &(hdr_ext->stt_lst), 0.0, verbose == 3);

  // ////////////////////////////////////////////////////////////////
  
  // Finished with primary header information   
  
  // ////////////////////////////////////////////////////////////////
  
  if (verbose == 3)
    cerr << "FITSArchive::load_header finished with primary HDU" 
	 << endl;
  
  // Load the processing history
  load_ProcHistory (fptr);

  // Load the digitiser statistics
  load_DigitiserStatistics (fptr);
  
  // Load the original bandpass data
  load_Passband (fptr);

  // Load the flux calibrator extension
  load_FluxCalibratorExtension (fptr);

  // Load the calibrator stokes parameters
  load_CalibratorStokes (fptr);

  // Load the calibration model description
  load_PolnCalibratorExtension (fptr);

  // Load the ephemeris from the FITS file
  fits_movnam_hdu (fptr, BINARY_TBL, "PSREPHEM", 0, &status);

  if (status == 0 && get_type() == Signal::Pulsar) {

    ephemeris = new psrephem;
    ephemeris->load(fptr);
    set_dispersion_measure( ephemeris->get_dm() );
    set_rotation_measure( ephemeris->get_double(EPH_RM) );

    if (verbose == 3)
      cerr << "FITSArchive::load_header ephemeris loaded" << endl;

  }
  else {

    ephemeris = 0;
    set_dispersion_measure (0);
    set_rotation_measure (0);

    if (verbose == 3)
      cerr << "FITSArchive::load_header no ephemeris" << endl;

  }

  // Load the polyco from the FITS file

  status = 0;
  fits_movnam_hdu (fptr, BINARY_TBL, "POLYCO", 0, &status);

  if (status == 0) {

    model = new polyco;
    model->load (fptr, &extra_polyco);
    hdr_model = new polyco (*model);

    if (verbose == 3)
      cerr << "FITSArchive::load_header polyco loaded" << endl;

  }
  else {

    hdr_model = model = 0;

    if (verbose == 3)
      cerr << "FITSArchive::load_header no polyco" << endl;

  }

  if (correct_P236_reference_epoch)
    P236_reference_epoch_correction ();

  // Move to the SUBINT Header Data Unit

  status = 0;
  fits_movnam_hdu (fptr, BINARY_TBL, "SUBINT", 0, &status);

  if (status == 0) {

    // Get the number of rows (ie. the number of sub-ints)
    
    long numrows = 0;
    fits_get_num_rows (fptr, &numrows, &status);

    set_nsubint(numrows);
    
    if (verbose == 3)
      cerr << "FITSArchive::load_header there are " << numrows << " subints"
	   << endl;

    dfault = "";
    psrfits_read_key (fptr, "INT_TYPE", &tempstr, dfault, verbose == 3);
    
    if (tempstr != "TIME" && tempstr != "") {

      if (tempstr == "BINPHSPERI")
	add_extension(new PeriastronOrder());
      else if (tempstr == "BINPHSASC")
	add_extension(new BinaryPhaseOrder());
      else if (tempstr == "BINLNGPERI")
	add_extension(new BinLngPeriOrder());
      else if (tempstr == "BINLNGASC")
	add_extension(new BinLngAscOrder());
      else
	throw Error(InvalidParam, "FITSArchive::load_header",
		    "unknown INT_TYPE=" + tempstr);
      
      get<Pulsar::IntegrationOrder>()->resize(get_nsubint());

    }

  }
  else if (verbose == 3)
    cerr << "FITSArchive::load_header no sub-integrations" << endl;

  status = 0;
  
  // Finished with the file for now
  fits_close_file (fptr, &status);
  
  if (status)
    throw FITSError (status, "Pulsar::FITSArchive::load_header",
		     "fits_close_file");

  if (verbose == 3)
    cerr << "FITSArchive::load_header exit" << endl;
  
}
catch (Error& error) {
  throw error += "FITSArchive::load_header";
}

//
// End of load_header function
// /////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////

/* This correction applies only to pulsar observations made during the
   commissioning of the WBC.  As far as I know, this affects only P236.  

   Symptom: The pulses from different archives line up, despite the fact
   that the phases predicted by the polyco for the reference epochs do not.
   Consequently, if you try to line them up using the polyco, they do not.

   Remedy: Truncate the phase of the reference epoch to zero.
*/

void Pulsar::FITSArchive::P236_reference_epoch_correction ()
{
   FITSHdrExtension*  hdr_ext  = get<FITSHdrExtension>();

   if (!hdr_ext) {
     throw Error (InvalidParam, "FITSArchive::P236_reference_epoch_correction",
		  "No FITSHdrExtension found");
   }

  if (!model || get_type() != Signal::Pulsar)
    return;

  MJD original_reference_epoch = hdr_ext->start_time;
  Phase original_phase = model->phase(hdr_ext->start_time);

  hdr_ext->start_time = model->iphase( original_phase.Floor() );

  if(verbose == 3)
    cerr << "Pulsar::FITSArchive::P236_reference_epoch_correction"
    "\n   original reference epoch=" << original_reference_epoch <<
    "\n                      phase=" << original_phase <<
    "\n  corrected reference epoch=" << hdr_ext->start_time <<
    "\n                      phase=" << model->phase(hdr_ext->start_time)
	 << endl;  
}


// /////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////
//! An unload function to write FITSArchive data to a FITS file on disk.

void Pulsar::FITSArchive::unload_file (const char* filename) const
{

  if (!filename)
    throw Error (InvalidParam, "FITSArchive::unload_file", 
                 "filename unspecified");
try {

  if (verbose == 3)
    cerr << "FITSArchive::unload_file (" << filename << ")" << endl
	 << "  with " << get_nextension() << " Extensions" << endl;

  fitsfile* fptr = 0;

  // status returned by FITSIO routines
  int status = 0;

  // To create a new file we need a FITS file template to provide the format

  char* template_file = getenv ("PSRFITSDEFN");
  if (!template_file)
    throw Error (FailedCall,
  		 "FITSArchive::unload_file", "PSRFITSDEFN not defined");
 
  if (verbose == 3)
    cerr << "FITSArchive::unload_file creating file " 
	 << filename << endl << "   using template " << template_file << endl;

  string clobbername = "!";
  clobbername += filename;

  /* the following three commands:

     fits_create_file
     fits_execute_template
     fits_movabs_hdu

     are equivalent to:

     fits_create_template

     except that they do not cause segmentation faults.
  */

  if (verbose == 3)
    cerr << "FITSArchive::unload_file call fits_create_file "
      "(" << clobbername << ")" << endl;

  fits_create_file (&fptr, clobbername.c_str(), &status);
  if (status)
    throw FITSError (status, "FITSArchive::unload_file",
		     "fits_create_file (%s)", clobbername.c_str());

  if (verbose == 3)
    cerr << "FITSArchive::unload_file call fits_execute_template "
      "(" << template_file << ")" << endl;

  fits_execute_template (fptr, template_file, &status);
  if (status)
    throw FITSError (status, "FITSArchive::unload_file",
		     "fits_execute_template (%s)", template_file);

  fits_movabs_hdu (fptr, 1, 0, &status);
  if (status)
    throw FITSError (status, "FITSArchive::unload_file",
		     "fits_moveabs_hdu");


  // do not return comments in fits_read_key
  char* comment = 0;

  // Write the source name

  char* telescope;
  telescope = const_cast<char*>(::Telescope::name(get_telescope_code()));

  fits_update_key (fptr, TSTRING, "TELESCOP", telescope, comment, &status);

  string source = get_source();
  
  fits_update_key (fptr, TSTRING, "SRC_NAME",
		   const_cast<char*>(source.c_str()), comment, &status);
    
  AnglePair radec = get_coordinates().getRaDec();
  string RA = radec.angle1.getHMS();
  string DEC = radec.angle2.getDMS();

  string coord1, coord2;
  const FITSHdrExtension* hdr_ext = get<FITSHdrExtension>();

  if (hdr_ext) {
    
    if (verbose == 3)
      cerr << "Pulsar::FITSArchive::unload_file FITSHdrExtension" << endl;
    
    unload (fptr, hdr_ext);
    hdr_ext->get_coord_string( get_coordinates(), coord1, coord2 );

  }
  
  else {

    // If no FITSHdrExtension is present, assume J2000 Equatorial

    coord1 = RA;
    coord2 = DEC;

    psrfits_update_key (fptr, "COORD_MD", "EQUAT");
    psrfits_update_key (fptr, "EQUINOX", "J2000");

  }

  // Virtual Observatory compatibility (redundant)
  psrfits_update_key (fptr, "RA", RA);
  psrfits_update_key (fptr, "DEC", DEC); 

  psrfits_update_key (fptr, "STT_CRD1", coord1);
  psrfits_update_key (fptr, "STT_CRD2", coord2); 

  string obs_mode;
  
  if (get_type() == Signal::Pulsar)
    obs_mode = "PSR";
  else if (get_type() == Signal::PolnCal)
    obs_mode = "CAL";
  else if (get_type() == Signal::FluxCalOn)
    obs_mode = "FON";
  else if (get_type() == Signal::FluxCalOff)
    obs_mode = "FOF";
  else if (get_type() == Signal::Calibrator)
    obs_mode = "PCM";
  else
    obs_mode = "UNKNOWN";
  
  fits_update_key (fptr, TSTRING, "OBS_MODE", 
		   const_cast<char*>(obs_mode.c_str()), comment, &status);

  {
    const ObsExtension* ext = get<ObsExtension>();
    if (ext) 
      unload (fptr, ext);
  }

  {

    const WidebandCorrelator* ext = get<WidebandCorrelator>();
    if (ext) 
      unload (fptr, ext);

  }

  {
    const Backend* backend = get<Backend>();

    if (backend) {
      
      if (verbose == 3)
	cerr << "FITSArchive::unload " << backend->get_extension_name()
	     << " name=" << backend->get_name() << endl;
      
      psrfits_update_key (fptr, "BACKEND",  backend->get_name());
      
      int be_dcc = backend->get_downconversion_corrected();
      psrfits_update_key (fptr, "BE_DCC", be_dcc);
 
      int be_phase = backend->get_argument();
      psrfits_update_key (fptr, "BE_PHASE", be_phase);

    }
    
  }

  {
    const ITRFExtension* ext = get<ITRFExtension>();
    if (ext) 
      unload (fptr, ext);
  }

  {
    const Receiver* ext = get<Receiver>();
    if (ext) 
      unload (fptr, ext);
  }

  {
    const CalInfoExtension* ext = get<CalInfoExtension>();
    if (ext) 
      unload (fptr, ext);
  }
  
  long day    = 0;
  long sec    = 0;
  double frac = 0.0;
 
  if (hdr_ext) {

    MJD hdr_epoch = hdr_ext->start_time;

    if (model) {

      unsigned jsubint = 0;
      for (; jsubint < get_nsubint(); jsubint++)
	if (get_Integration(jsubint)->get_duration() != 0.0)
	  break;

      if (jsubint < get_nsubint()) {

	const Integration* integ = get_Integration(jsubint);

	Phase stt_phs = model->phase(integ->get_epoch());
	Phase off_phs = model->phase(hdr_epoch);
	Phase dphase  = off_phs - stt_phs;
      
	double dtime = dphase.fracturns() * integ->get_folding_period();
	hdr_epoch -= dtime;

      }

    }

    day = (long)(hdr_epoch.intday());
    sec = (long)(hdr_epoch.get_secs());
    frac = hdr_epoch.get_fracsec();
  }

  fits_update_key (fptr, TLONG, "STT_IMJD", &day, comment, &status);
  fits_update_key (fptr, TLONG, "STT_SMJD", &sec, comment, &status);
  fits_update_key (fptr, TDOUBLE, "STT_OFFS", &frac, comment, &status);

  if (status)
    throw FITSError (status, "FITSArchive::unload_file",
		     "fits_update_key STT_MJD");

  if (verbose == 3)
    cerr << "FITSArchive::unload_file finished in primary header" << endl;
  
  // Finished with primary header information
  
  // /////////////////////////////////////////////////////////////////
    
  // Move to the Processing History HDU and set more information
  
  const_cast<FITSArchive*>(this)->update_history();
  
  const ProcHistory* history = get<ProcHistory>();
  
  if (!history)
    throw Error (InvalidState,"Pulsar::FITSArchive::unload","no ProcHistory");

  unload (fptr, history);
  
  if (verbose == 3)
    cerr << "FITSArchive::unload_file finished with processing history" 
	 << endl;

  // Write the ephemeris to the FITS file
  
  if (ephemeris) {

    ephemeris->set_dm(dispersion_measure);
    ephemeris->set_double (EPH_RM, rotation_measure);

    ephemeris->unload(fptr);

    if (verbose == 3)
      cerr << "FITSArchive::unload_file ephemeris written" << endl;

  }
  else
    delete_hdu (fptr, "PSREPHEM");


  // Write the polyco to the FITS file

  if (model) { 

   model->unload(fptr);
  
   if (verbose == 3)
     cerr << "FITSArchive::unload_file polyco written" << endl;

  }
  else
    delete_hdu (fptr, "POLYCO");

  // Unload some of the other HDU's

  const DigitiserStatistics* digistats = get<DigitiserStatistics>();
  if (digistats)
    unload (fptr, digistats);
  else
    delete_hdu (fptr, "DIG_STAT");

  const Passband* passband = get<Passband>();
  if (passband)
    unload (fptr, passband);
  else
    delete_hdu (fptr, "BANDPASS");

  const FluxCalibratorExtension* fce = get<FluxCalibratorExtension>();
  if (fce)
    unload (fptr, fce);
  else
    delete_hdu (fptr, "FLUX_CAL");

  const CalibratorStokes* stokes = get<CalibratorStokes>();
  if (stokes)
    unload (fptr, stokes);
  else
    delete_hdu (fptr, "CAL_POLN");

  const PolnCalibratorExtension* pce = get<PolnCalibratorExtension>();
  if (pce)
    unload (fptr, pce);
  else
    delete_hdu (fptr, "FEEDPAR");

  // Now write the actual integrations to file

  if (nsubint > 0)
    unload_integrations (fptr);
  else
    delete_hdu (fptr, "SUBINT");

  fits_close_file (fptr, &status);

  if (status)
    throw FITSError (status, "Pulsar::FITSArchive::unload_file",
		     "fits_close_file");

  if (verbose == 3)
    cerr << "FITSArchive::unload_file fits_close_file " << "(" << filename 
	 << ")" << " complete" << endl;
}
catch (Error& error) {
  throw error += "FITSArchive::unload_file";
}

}

// End of unload_file function
// //////////////////////////////////////////
// //////////////////////////////////////////



// !A quick little helper function for internal use.
// /////////////////////////////////////////////////

int Pulsar::FITSArchive::truthval (bool condition) const
{
  if (condition)
    return 1;
  else
    return 0;
}

// EOF
// ///
    
    











