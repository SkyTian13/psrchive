/***************************************************************************
 *
 *   Copyright (C) 1999 by Willem van Straten
 *   Licensed under the Academic Free License version 2.1
 *
 ***************************************************************************/
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "psrephem.h"
#include "tempo++.h"
#include "Predict.h"

#include "ephio.h"
#include "strutil.h"
#include "dirutil.h"

#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <assert.h>

#include <iostream>
using namespace std;


/* convertunits declaration removed from header file; needs config.h to be
   defined on every architecture */

#define convertunits F77_FUNC (convertunits,CONVERTUNITS)
extern "C" int convertunits (double* value, double* error,
			     int* status, int* convert);

psrephem::~psrephem(){ destroy(); }

// defines the recognized filename extensions used for pulsar ephemeris files
vector<string> psrephem::extensions ()
{
  vector <string> retval;

  retval.push_back (string (".eph"));
  retval.push_back (string (".par"));

  return retval;
}

bool Pulsar::Parameters::verbose = 0;

static char ephemstr [EPH_NUM_KEYS][EPH_STR_LEN];

void psrephem::init()
{
  nontempo11.erase();
  parmStatus    = NULL;
  value_str     = NULL;
  value_double  = NULL;
  value_integer = NULL;
  error_double  = NULL;

  tempo11 = false;
}

void psrephem::size_dataspace()
{
//   if (!tempo11)  {
//     destroy ();
//     return;
//   }

  if (parmStatus != NULL)  {
    // the arrays have already been initialized.  zero them
    if (verbose)
      fprintf (stderr, "psrephem::size_dataspace zero\n");
    zero_work();
    return;
  }
  
  parmStatus    = new int    [EPH_NUM_KEYS];
  value_double  = new double [EPH_NUM_KEYS];
  value_str     = new string [EPH_NUM_KEYS];
  value_integer = new int    [EPH_NUM_KEYS];
  error_double  = new double [EPH_NUM_KEYS];
  
  zero_work();
}

void psrephem::zero()
{
  tempo11 = true;
  size_dataspace ();
}


void psrephem::zero_work()
{
  static string tempo_safe_string (" ");
  
  for (int i=0;i<EPH_NUM_KEYS;i++) {
    parmStatus   [i] = 0;
    value_double [i] = 0.0;
    value_integer[i] = 0;
    value_str    [i] = tempo_safe_string;
    error_double [i]  = 0.0;
  }
}

void psrephem::destroy()
{
  if (parmStatus)  {
    delete [] parmStatus;
    delete [] value_double;
    delete [] value_integer;
    delete [] error_double;
    delete [] value_str;
  }
  init ();
}

psrephem::psrephem (const char* psr_name, int use_cwd)
{
  init();
  if (create (psr_name, use_cwd) < 0) {
    fprintf (stderr, "psrephem::psrephem error creating epemeris for %s.\n",
	     psr_name);
    throw Error(FailedCall, "psrephem::psrephem");
  }
}

psrephem::psrephem (const char* filename)
{
  init();
  if (load (filename) < 0) {
    fprintf (stderr, "psrephem::psrephem error loading %s.\n", filename);
    throw Error(FailedCall, "psrephem::psrephem");
  }
}

int psrephem::create (const char* psr_name, int use_cwd)
{
  if (verbose)
    fprintf (stderr, "psrephem::create '%s'\n", psr_name);
 
  string filename = par_lookup (psr_name, use_cwd);
  if (filename.empty()) {
    fprintf (stderr, "psrephem::create no ephemeris file for %s found.\n",
	     psr_name);
    return -1;
  }
  if (verbose)
    fprintf (stderr, "psrephem::create loading '%s'\n", filename.c_str());
  if (load (filename.c_str()) < 0) {
    fprintf (stderr, "psrephem::create error loading %s.\n", filename.c_str());
    return -1;
  }
  return 0;
}

int psrephem::load (const char* filename)
{
  if (verbose) 
    cerr << "psrephem::load enter" << endl;

  tempo11 = 1;
  size_dataspace();
  
  if (verbose)
    cerr << "psrephem::load rd_eph (" << filename << ")" << endl;

  rd_eph (const_cast<char*>(filename), parmStatus, ephemstr, value_double, 
	  value_integer, error_double);

  int all_zero = 1;
  for (int i=0;i<EPH_NUM_KEYS;i++)  {
    if (parmStatus[i]) {
      value_str[i] = ephemstr [i];
      all_zero = 0;
    }
  }
  if (all_zero) {
    if (verbose)
      fprintf (stderr, "psrephem::load WARNING "
	       "tempo11-style load of '%s' failed\n", filename);
    return old_load (filename);
  }

  if (verbose)
    fprintf (stderr,"psrephem::load tempo11-style loaded '%s' ok\n", filename);

  return 0;
}

int psrephem::old_load (const char* filename)
{
  tempo11 = 0;
  size_dataspace();

  FILE* fptr = fopen(filename,"r");
  if (fptr == NULL) {
    fprintf (stderr, "psrephem::old_load error fopen(%s)", filename);
    perror (":");
  }
  if (stringload (&nontempo11, fptr) < 0)  {
    fprintf (stderr, "psrephem::old_load error\n");
    return -1;
  }
  fclose(fptr);
  return 0;
}

int psrephem::unload (const char* filename) const
{
//   if (!tempo11)
//     return old_unload (filename);

  if (verbose)
    cerr << "psrephem::unload copying strings" << endl;

  for (int ieph=0; ieph<EPH_NUM_KEYS; ieph++) {
    assert (value_str[ieph].length() < EPH_STR_LEN -1);
    strcpy (ephemstr[ieph], value_str[ieph].c_str());
  }

  if (verbose)
    cerr << "psrephem::unload calling wr_eph" << endl;

  int istat = wr_eph (const_cast<char*>(filename), parmStatus, ephemstr,
		      value_double, value_integer, error_double);
  if (!istat) {
    fprintf (stderr, "psrephem::unload error wr_eph '%s'\n", filename);
    return -1;
  }

  if (verbose)
    fprintf (stderr, "psrephem::unload unloaded %s ok\n", filename);

  return 0;
}

int psrephem::old_unload (const char* filename) const
{
  if (tempo11)
    return -1;

  FILE* fptr = fopen (filename,"w");
  if (fptr == NULL) {
    fprintf (stderr, "psrephem::old_unload error fopen(%s)", filename);
    perror (":");
    return -1;
  }
  if (fwrite (nontempo11.c_str(), 1, nontempo11.length(), fptr) 
	< nontempo11.length())  {
    perror ("psrephem::old_unload error");
    return -1;
  }
  fclose (fptr);
  return 0;
}

string psrephem::par_lookup (const char* name, int use_cwd)
{
  string psr_name;

  if (name[0] == 'J' || name[0] == 'B')
    psr_name = name + 1;
  else
    psr_name = name;

  if (use_cwd) {
    vector <string> exts = extensions ();
    for (unsigned iext=0; iext < exts.size(); iext++) {
      /* Look for jname.ext in current directory */
      string filename = psr_name + exts[iext];
      if (file_exists(filename.c_str())) {
	if (verbose)
	  cerr << "psrephem::Using " << filename << " from cwd" << endl;
	return filename;
      }
    }
  }

  string tempo_pardir = Tempo::get_configuration("PARDIR");

  if (tempo_pardir.length()) {

    vector <string> exts = extensions ();
    for (unsigned iext=0; iext < exts.size(); iext++) {

      string filename = tempo_pardir + psr_name + exts[iext];

      if (verbose)
	cerr << "psrephem::par_lookup in TEMPO PARDIR '" 
	     << filename << "'" << endl;

      if (file_exists(filename.c_str())) {
	if (verbose)
	  cerr << "psrephem:: Using " << filename 
	       << " from PARDIR:" << tempo_pardir << endl;
	return filename;
      }

    }

  }
  
  /* Create name.eph in local directory */ 

#ifdef HAVE_PSRCAT

  string command = "psrcat -e " + psr_name + " > " + psr_name + ".eph";
  string catalogue = "psrcat";

#else

  string command = "psrinfo -e " + psr_name;
  string catalogue = "psrinfo";

#endif

  if (verbose)
    cerr << "psrephem:: Creating ephemeris by " << catalogue 
	 << " -e " << psr_name <<endl;

  // start with a clean working directory
  removedir (Tempo::get_directory().c_str());

  char cwd[FILENAME_MAX];

  if (getcwd (cwd, FILENAME_MAX) == NULL)
    throw Error (FailedSys, "psrephem", "failed getcwd");

  // note that Tempo::get_directory creates the directory if it doesn't exist
  if (chdir (Tempo::get_directory().c_str()) != 0)
    throw Error (FailedSys, "psrephem",
		 "failed chdir(" + Tempo::get_directory() + ")");

  int retval = system(command.c_str());

  if (chdir (cwd) != 0)
    throw Error (FailedSys, "psrephem", "failed chdir(%s)", cwd);

  if (retval != 0) {
    cerr << "psrephem:: Error executing system (" + command + ")" << endl;
    return "";
  }

  vector<string> filenames;
  dirglob (&filenames, Tempo::get_directory() + "/*.eph");

  if (filenames.size() != 1)
    throw Error (InvalidState, "psrephem", "%s created %d files",
		 catalogue.c_str(),filenames.size());

  string filename = filenames[0];

  if (file_exists(filename.c_str())) {
    if (verbose)
      cerr << "psrephem:: Using '" + filename + "'" << endl;
    return filename;
  }

  if (verbose)
    fprintf (stderr, "psrephem:: Cannot find %s after call to %s.\n", 
	     filename.c_str(),catalogue.c_str());

  return "";
}

string psrephem::psrname() const
{
  if (parmStatus[EPH_PSRJ]==1)
    return value_str[EPH_PSRJ];

  else if (parmStatus[EPH_PSRB]==1)		
    return value_str[EPH_PSRB];
 
  return "unknown";
}


double psrephem::get_dm() const
{
  // Removed tempo11 check because it's now possible
  // to obtain dm for pre-tempo11 ephemeris files
  //  if (tempo11 && parmStatus[EPH_DM])
  if (parmStatus[EPH_DM])
    return value_double[EPH_DM];

  return 0;
}

void psrephem::set_dm( double dm )
{
  if (!parmStatus[EPH_DM])
    parmStatus[EPH_DM] = 1;

  value_double[EPH_DM] = dm;
}

double psrephem::jra() const
{
  if (parmStatus[EPH_RAJ])
    return value_double[EPH_RAJ];
  
  throw Error(InvalidParam, "psrephem::jra",
	      "Error determining pulsar RA");
}

double psrephem::jdec() const
{
  if (parmStatus[EPH_DECJ])
    return value_double[EPH_DECJ];
  
  throw Error(InvalidParam, "psrephem::jdec",
	      "Error determining pulsar DEC");
}

double psrephem::omega() const
{
  if (tempo11 && parmStatus[EPH_OM])
    return value_double[EPH_OM];
  
  throw Error(InvalidParam, "psrephem::omega",
	      "Error determining pulsar OMEGA");
}

double psrephem::omdot() const
{
  if (tempo11 && parmStatus[EPH_OMDOT])
    return value_double[EPH_OMDOT];
  
  throw Error(InvalidParam, "psrephem::omdot",
	      "Error determining pulsar OMDOT");
}

double psrephem::ecc() const
{
  if (tempo11 && parmStatus[EPH_E])
    return value_double[EPH_E];
  
  throw Error(InvalidParam, "psrephem::ecc",
	      "Error determining pulsar E");
}

double psrephem::t0() const
{
  if (tempo11 && parmStatus[EPH_T0]) {
    MJD current_epoch = MJD (value_integer[EPH_T0],
			     value_double [EPH_T0]);
    return current_epoch.in_days();
  }
  
  throw Error(InvalidParam, "psrephem::t0",
	      "Error determining pulsar T0");
}

double psrephem::a1() const
{
  if (tempo11 && parmStatus[EPH_A1])
    return (value_double[EPH_A1]);
  
  throw Error(InvalidParam, "psrephem::a1",
	      "Error determining pulsar A1");
}

double psrephem::pb() const
{
  if (tempo11 && parmStatus[EPH_PB])
    return (value_double[EPH_PB]);
  
  throw Error(InvalidParam, "psrephem::pb",
	      "Error determining pulsar PB");
}

void psrephem::nofit()
{
  if (!tempo11)
    return;

  for (int i=0;i<EPH_NUM_KEYS;i++) {
    if (parmStatus[i]==2) parmStatus[i]=1;
  }
}

void psrephem::fitall()
{
  if (!tempo11)
    return;

  for (int i=0;i<EPH_NUM_KEYS;i++) {
    if (parmStatus[i]==1) parmStatus[i]=2;
  }
}

void psrephem::efac (float fac)
{
  if (!tempo11)
    return;

  for (int i=0;i<EPH_NUM_KEYS;i++)
    if (parmStatus[i]==2) error_double[i]*=fac;
}

Pulsar::Parameters* psrephem::clone () const
{
  return new psrephem (*this);
}

Pulsar::Generator* psrephem::generator () const
{
  return new Tempo::Predict (this);
}

bool psrephem::equals (const Pulsar::Parameters* p) const
{
  const psrephem* that = dynamic_cast<const psrephem*>(p);
  if (!that)
    return false;
  return *this == *that;
}

void psrephem::load (FILE* fptr)
{
  string total;
  if (stringload (&total, fptr) < 0)
    throw Error (FailedSys, "psrephem::load(FILE*)", "stringload");

  load (&total);
}

void psrephem::unload (FILE* fptr) const
{
  string out;
  if (!tempo11)
    out = nontempo11;
  else if (unload(&out) < 0)
    throw Error (FailedCall, "psrephem::unload(FILE*)",
		 "unload(string*) failed");

  size_t size = out.length();
  size_t bout = fwrite (out.c_str(), 1, size, fptr);
  if (bout < size)
    throw Error (FailedSys, "psrephem::unload(FILE*)", "fprintf");

  fflush (fptr);
}

//! Return the name of the source
std::string psrephem::get_name () const
{
  return psrname ();
}
  
//! Return the coordinates of the source
sky_coord psrephem::get_coordinates () const
{
  return sky_coord ( jra()*2.0*M_PI, jdec()*2.0*M_PI );
}

//! Return the dispersion measure
double psrephem::get_dispersion_measure () const
{
  if (parmStatus[EPH_DM])
    return value_double[EPH_DM];

  return 0;
}

//! Return the rotation measure
double psrephem::get_rotation_measure () const
{
  if (parmStatus[EPH_RM])
    return value_double[EPH_RM];

  return 0;
}








static char* ephemblock = NULL;
static int*  correct    = NULL;
static void prepare_static_load_area ()
{
  if (ephemblock == NULL) {
    ephemblock = new char [EPH_NUM_KEYS * EPH_STR_LEN];
    assert (ephemblock != NULL);
  }
  if (correct == NULL) {
    correct = new int [EPH_NUM_KEYS];
    assert (correct != NULL);
  }
  for (int i=0; i<EPH_NUM_KEYS; i++)
    correct [i] = 0;

  for (int c=0; c<EPH_NUM_KEYS*EPH_STR_LEN; c++)
    ephemblock[c] = ' ';
}

void f2cstr (char* str, unsigned length)
{
  unsigned i = length-1;
 
  while (str[i] == ' ') {
    str[i] = '\0';
    if (i == 0)
      break;
    i--;
  }
}

int psrephem::load (string* instr)
{
  if (verbose)
    cerr << "psrephem::load (string*) *****" << endl
	 << *instr << "***** END" << endl;

  tempo11 = 1;
  size_dataspace();
  prepare_static_load_area ();

  nontempo11 = *instr;  // just in case parsing fails
  int old_ephem = 0;

	vector<string> eph_lines;

  while (instr -> length() > 1) {
    // get the next line from the incoming text
    string line ( stringtok (instr, "\n") );
    if (verbose)
      cerr << "psrephem::load '" << line << "' len=" << line.length() 
	   << " instr.len=" << instr -> length() << endl;

    if (line.length() < 1)
      continue;

		// store the line in a vector for processing later
		eph_lines.push_back(line);

    rd_eph_str (parmStatus, ephemblock, value_double, value_integer,
		error_double, correct, &old_ephem, 
		const_cast<char*>( line.c_str() ));
  }

  // convertunits_ defined in ephio.f
  convertunits (value_double, error_double, parmStatus, correct);
  if (verbose)
    cerr << "psrephem::load units converted" << endl;

  bool all_zero = 1;
  for (int ieph=0; ieph<EPH_NUM_KEYS; ieph++)  {
    if (parmStatus[ieph] == 0)
      continue;

    char* strval = ephemblock + ieph * EPH_STR_LEN;
    f2cstr (strval, EPH_STR_LEN);
    value_str[ieph] = strval;

    all_zero = 0;
  }
  
  if (all_zero) {
    if (verbose) {
      cerr << "psrephem::load WARNING "
	"tempo11-style load of '" << nontempo11 << "' failed" << endl;
		}
		
		// From here, need to parse the older style ephem
		read_old_ephem_str(eph_lines, parmStatus, value_str, value_double, value_integer);		
		
    tempo11 = false;
  }

  return 0;
}

void psrephem::read_old_ephem_str(vector<string> lines, 
                                  int *pstatus,
                                  string *val_str, 
																	double * val_double, 
																	int * val_int) {
	
	// Start at 1 because the first line is just a row of dashes -----
	int i = 1;

	////////////
	// Line 1
	
	// Name
	string psrname = lines[i].substr(0, 19);
	
	// get rid of white space
	string::size_type start = psrname.find_first_not_of (" \t");
	string::size_type end = psrname.find_last_not_of(" \t");
	
	if (start != string::npos && end != string::npos) {
		psrname = psrname.substr(start, end-start+1);
		pstatus[EPH_PSRB] = 1;
		val_str[EPH_PSRB] = psrname;
		
		if (psrname.length() > 7) {
			
			pstatus[EPH_PSRJ] = 1;
			val_str[EPH_PSRJ] = psrname;
		}

	}
	
	
	// RAJ
	string raj_str = lines[i].substr(19, 20);
	string::size_type j = raj_str.find(".", 0);
	
	if (j != string::npos) {
	
		string raj_sec_str = raj_str.substr(j-2, raj_str.length() - (j-2));
		string raj_min_str = raj_str.substr(j-4, 2);
		string raj_hour_str = raj_str.substr(0, 
		   raj_str.length() - (raj_sec_str.length() + raj_min_str.length()));

		double raj_hour = atof(raj_hour_str.c_str());
		double raj_min = atof(raj_min_str.c_str());
		double raj_sec = atof(raj_sec_str.c_str());

		raj_str = raj_hour_str + ":" + raj_min_str + ":" + raj_sec_str;
		double raj = (raj_hour + raj_min/60 + raj_sec/3600)/24;

		pstatus[EPH_RAJ] = 1;
		val_str[EPH_RAJ] = raj_str;
		val_double[EPH_RAJ] = raj;
	
	}
	
	// DECJ
	string decj_str = lines[i].substr(40, 20);
	j = decj_str.find(".", 0);
	
	if (j != string::npos) {
		string decj_sec_str = decj_str.substr(j-2, decj_str.length() - (j-2));
		string decj_min_str = decj_str.substr(j-4, 2);
		string decj_deg_str = decj_str.substr(0, 
		decj_str.length() - (decj_sec_str.length() + decj_min_str.length()));

		double decj_deg = atof(decj_deg_str.c_str());
		double decj_min = atof(decj_min_str.c_str());
		double decj_sec = atof(decj_sec_str.c_str());

		decj_str = decj_deg_str + ":" + decj_min_str + ":" + decj_sec_str;
		double decj = (decj_deg + decj_min/60 + decj_sec/3600) / 360;

		pstatus[EPH_DECJ] = 1;
		val_str[EPH_DECJ] = decj_str;
		val_double[EPH_DECJ] = decj;
	}
		
	// PMRA / PMDEC
	string pmra_str = lines[i].substr(60, 10);
	start = pmra_str.find_first_of ("1234567890");
	
	if (start != string::npos) {
		double pmra = atof(pmra_str.c_str());
		pstatus[EPH_PMRA] = 1;
		val_str[EPH_PMRA] = pmra_str;
		val_double[EPH_PMRA] = pmra;
		
	}
	
	string pmdec_str = lines[i].substr(70, 10);
	start = pmdec_str.find_first_of ("1234567890");
	
	if (start != string::npos) {
		double pmdec = atof(pmdec_str.c_str());
		pstatus[EPH_PMDEC] = 1;
		val_str[EPH_PMDEC] = pmdec_str;
		val_double[EPH_PMDEC] = pmdec;
	}
	
	
	
	i++;
	
	//////////////
	// Line 2
	
	string p0_str = lines[i].substr(1,19);
	start = p0_str.find_first_of ("1234567890");
	
	double p0 = 0;
	if (start != string::npos) {
		p0 = atof(p0_str.c_str());
		pstatus[EPH_F] = 1;
		val_str[EPH_F] = p0_str;
		val_double[EPH_F] = 1/p0;
	}
	
	string p1_str = lines[i].substr(20, 20);
	start = p1_str.find_first_of ("1234567890");
	double p1 = 0;
	if (start != string::npos) {
		p1 = atof(p1_str.c_str());
		pstatus[EPH_F1] = 1;
		val_str[EPH_F1] = p1_str;
		val_double[EPH_F1] = p1/pow(p0,2);
		
	}
		
	string pepoch_str = lines[i].substr(40, 20);
	start = pepoch_str.find_first_of ("1234567890");
	if (start != string::npos) {
		int pepoch = atoi(pepoch_str.c_str());
	
		pstatus[EPH_PEPOCH] = 1;
		val_str[EPH_PEPOCH] = pepoch_str;
		val_int[EPH_PEPOCH] = pepoch;
	}
	
	
	string p2_str = lines[i].substr(60, 10);
	start = p2_str.find_first_of ("1234567890");
	double p2 = 0;
	if (start != string::npos) {
		p2 = atof(p2_str.c_str());
		
		pstatus[EPH_F2] = 1;
		val_str[EPH_F2] = p2_str;
		
		
		val_double[EPH_F2] = -p2/pow(p0,2) + 2*pow(p1,2)/pow(p0,3);
		
	}
		
	string px_str = lines[i].substr(70, 10);
	start = px_str.find_first_of ("1234567890");
	if (start != string::npos) {
		double px = atof(px_str.c_str());
		
		pstatus[EPH_PX] = 1;
		val_str[EPH_PX] = px_str;
		val_double[EPH_PX] = px;
				
	}
	i++;
	
	////////////
	// Line 3
	
	
	string dm_str = lines[i].substr(8,12);
	start = dm_str.find_first_of ("1234567890");

	if (start != string::npos) {
		double dm = atof(dm_str.c_str());
		
		pstatus[EPH_DM] = 1;
		val_str[EPH_DM] = dm_str;
		val_double[EPH_DM] = dm;
		
	}
}																


int psrephem::unload (string* outstr) const
{
  if (!tempo11)  {
    *outstr += nontempo11;
    return nontempo11.size();
  }

  if (parmStatus == NULL)
    return 0;

  const int buflen = 80;
  char buffer[buflen];
  string newline ("\n");

  char ephstr [EPH_STR_LEN];
  unsigned bytes_out = 0;
  for (int ieph=0; ieph < EPH_NUM_KEYS; ieph++) {
    if (!parmStatus[ieph])
      continue;

    strcpy (ephstr, value_str[ieph].c_str());

    wr_eph_str (buffer, buflen, ieph, parmStatus[ieph], 
		ephstr, value_double[ieph], value_integer[ieph],
		error_double[ieph]);

    // if (verbose)
    //cerr << "   '" << buffer << "'" << endl;

    string lineout = buffer + newline;
    *outstr += lineout;
    bytes_out += lineout.size();
  }

  return bytes_out;
}

double psrephem::p(void) const
{
  if (!tempo11)
    return -1;

  if ((value_double[EPH_F])!=0.0)  {
    return (1.0/value_double[EPH_F]);
  } 
  else
    fprintf (stderr,"psrephem::p warning rotation frequency 0.0\n");
  return(1.0);
}

double psrephem::p_err(void) const
{
  if (!tempo11)
    return -1;

  if ((value_double[EPH_F])!=0.0){
    return (-1.0/value_double[EPH_F]/value_double[EPH_F]
	    *error_double[EPH_F]);
  } else
    fprintf(stderr,"psrephem::p_err warning rotation frequency 0.0\n");
  return(1.0);
}

psrephem::psrephem (const psrephem & p2)
{
  init ();
  *this = p2;
}

psrephem & psrephem::operator = (const psrephem & p2)
{
  if (this == &p2)
    return *this;

  destroy();
  init();
//   if(!p2.parmStatus)
//     return(*this);

  tempo11 = p2.tempo11;
  size_dataspace();
  
//  if (tempo11) {
    for (int i=0;i<EPH_NUM_KEYS;i++){
      parmStatus[i]=p2.parmStatus[i];
      value_double[i]=p2.value_double[i];
      value_integer[i]=p2.value_integer[i];
      error_double[i]=p2.error_double[i];
      value_str[i]=p2.value_str[i];
    }
//   }
//   else {
    nontempo11 = p2.nontempo11;
//  }
  return *this;
}

bool operator == (const psrephem &e1, const psrephem &e2)
{
  if (e1.parmStatus==NULL && e2.parmStatus==NULL)
    return 1;

  if ((e1.parmStatus==NULL && e2.parmStatus!=NULL) ||
      (e1.parmStatus!=NULL && e2.parmStatus==NULL))
    return 0;

  if (e1.tempo11 != e2.tempo11) {
    if (psrephem::verbose)
      cerr << "psrephem::operator== unequal tempo11 flags" << endl;
    return 0;
  }

  if (!e1.tempo11)
    return e1.nontempo11 == e2.nontempo11;

  for (int ieph=0;ieph<EPH_NUM_KEYS;ieph++) {

    if (e1.parmStatus[ieph] != e2.parmStatus[ieph]) {
      if (psrephem::verbose)
	cerr << "psrephem::operator== unequal parmStatus["
	     << parmNames[ieph] << "]" << endl;
      return 0;
    }
    
    if (e1.value_double[ieph] != e2.value_double[ieph]) {
      if (psrephem::verbose)
	cerr << "psrephem::operator== unequal value_double["
	     << parmNames[ieph] << "]" << endl;
      return 0;
    }
    
    if (e1.value_integer[ieph] != e2.value_integer[ieph]) {
      if (psrephem::verbose)
	cerr << "psrephem::operator== unequal value_integer["
	     << parmNames[ieph] << "]" << endl;
      return 0;
    }
    
    if (e1.error_double[ieph] != e2.error_double[ieph]) {
      if (psrephem::verbose)
	cerr << "psrephem::operator== unequal value_integer["
	     << parmNames[ieph] << "]" << endl;
      return 0;
    }
    
    if (e1.value_str[ieph] != e2.value_str[ieph])  {
      if (psrephem::verbose)
	cerr << "psrephem::operator== unequal value_integer["
	     << parmNames[ieph] << "]" << endl;
      return 0;
    }
    
  }

  return true;

}

bool operator != (const psrephem &e1, const psrephem &e2) {
  return ! operator == (e1,e2);
}

ostream& operator<< (ostream& ostr, const psrephem& eph)
{  
  string out;
  eph.unload (&out);
  ostr << out;
  return ostr;
}

// ///////////////////////////////////////////////////////////////////////
//
// set/get functions
//
// ///////////////////////////////////////////////////////////////////////

string psrephem::get_string  (int ephind)
{
  if (parmTypes[ephind] != 0)
    throw Error (InvalidParam, "psrephem::get_string",
                 "%s is not a string", parmNames[ephind]);

  if (tempo11 && parmStatus[ephind])
    return value_str[ephind];
  else
    return "";
}

double psrephem::get_double  (int ephind)
{
  if (parmTypes[ephind] != 1)
    throw Error (InvalidParam, "psrephem::get_double",
                 "%s is not a double", parmNames[ephind]);

  if (tempo11 && parmStatus[ephind])
    return value_double[ephind];
  else
    return 0.0;
}

MJD psrephem::get_MJD (int ephind)
{
  if (parmTypes[ephind] != 4)
    throw Error (InvalidParam, "psrephem::get_MJD",
                 "%s is not a MJD", parmNames[ephind]);

  if (tempo11 && parmStatus[ephind])
    return MJD (value_integer[ephind], value_double[ephind]);
  else
    return MJD::zero;
}

Angle psrephem::get_Angle (int ephind)
{
  if (parmTypes[ephind] != 2 && parmTypes[ephind] != 3)
    throw Error (InvalidParam, "psrephem::get_Angle",
                 "%s is not an  Angle", parmNames[ephind]);

  if (tempo11 && parmStatus[ephind]) {
    Angle ret;
    ret.setTurns (value_double[ephind]);
    return ret;
  }
  else
    return Angle();
}

int psrephem::get_integer (int ephind)
{
  if (parmTypes[ephind] != 5)
    throw Error (InvalidParam, "psrephem::get_integer",
                 "%s is not an integer", parmNames[ephind]);

  if (tempo11 && parmStatus[ephind])
    return value_integer[ephind];
  else
    return 0;
}

void psrephem::set_string (int ephind, const string& value)
{
  if (parmTypes[ephind] != 0)
    throw Error (InvalidParam, "psrephem::get_string",
                 "%s is not a string", parmNames[ephind]);

  value_str[ephind] = value;

  if (!parmStatus[ephind])
    parmStatus[ephind] = 1;
}

void psrephem::set_double (int ephind, double value)
{
  if (parmTypes[ephind] != 1)
    throw Error (InvalidParam, "psrephem::get_double",
                 "%s is not a double", parmNames[ephind]);

  value_double[ephind] = value;

  if (!parmStatus[ephind])
    parmStatus[ephind] = 1;
}

void psrephem::set_MJD (int ephind, const MJD& value)
{
  if (parmTypes[ephind] != 4)
    throw Error (InvalidParam, "psrephem::get_MJD",
                 "%s is not a MJD", parmNames[ephind]);

  value_integer[ephind] = value.intday();
  value_double[ephind] = value.fracday();

  if (!parmStatus[ephind])
    parmStatus[ephind] = 1;
}

void psrephem::set_Angle (int ephind, const Angle& value)
{
  if (parmTypes[ephind] != 2 && parmTypes[ephind] != 3)
    throw Error (InvalidParam, "psrephem::get_Angle",
                 "%s is not an  Angle", parmNames[ephind]);

  value_double[ephind] = value.getTurns();

  if (!parmStatus[ephind])
    parmStatus[ephind] = 1;
}

void psrephem::set_integer (int ephind, int value)
{
  if (parmTypes[ephind] != 5)
    throw Error (InvalidParam, "psrephem::get_integer",
                 "%s is not an integer", parmNames[ephind]);

  value_integer[ephind] = value;

  if (!parmStatus[ephind])
    parmStatus[ephind] = 1;
}

