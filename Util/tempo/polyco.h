/* this file is part of the 'polyco' module */
#ifndef __POLY_H
#define __POLY_H

#include <string>
#include <vector>
#include <fstream>
#ifdef sun
#include <strstream.h>
#endif
#ifdef __alpha
#include <strstream>
#endif
#include "Phase.h"
#include "MJD.h"
#ifdef MPI
#include "mpi.h"
#endif

class polynomial {

 public:
 
  string psrname;
  string date;
  string utc;
  bool tempov11;         // these parameters exist only when polyco 
                         // generated by versions of tempo > 11.0 (?)
  double doppler_shift;
  double log_rms_resid;
  Phase ref_phase;
  double f0;
  int telescope;
  double freq;
  bool binary;           // these parameters exist only for binaries
  double binph;
  double binfreq;
  float dm;
  MJD reftime;
  double nspan_mins;
  vector<double> coefs;

public:
  polynomial();
  polynomial(const polynomial &);
  ~polynomial(){};
  void init();

  polynomial & operator = (const polynomial &);

  int load (string* instr);
  int unload (string *outstr) const;
  int unload (ostream &ostr) const;
  int unload (FILE* fptr) const;

  void   prettyprint  () const;

  // Member functions to perform polyco calculations
  double period            (const MJD &t) const;
  Phase  phase             (const MJD &t) const;
  Phase  phase             (const MJD &t, float obs_freq) const;
  double frequency         (const MJD &t) const;
  bool   is_tempov11       () const {return (tempov11);};
  int    get_telescope     () const {return (telescope);};
  double get_freq          () const {return (freq);};
  MJD    get_reftime       () const {return (reftime);};
  double get_nspan         () const {return (nspan_mins);};
  float  get_dm            () const {return (dm);};
  int    get_ncoeff        () const {return (int) coefs.size();};
  double get_doppler_shift () const {return doppler_shift / 1e4;};

  MJD start_time () const
    { return reftime - nspan_mins * 60.0/2.0; };
  MJD end_time () const 
    { return reftime + nspan_mins * 60.0/2.0; };

  friend int operator == (const polynomial &, const polynomial &);
  friend int operator != (const polynomial &, const polynomial &);

  // MPI functions
#ifdef MPI
  friend int mpiPack_size (const polynomial&, MPI_Comm comm, int* size);
  friend int mpiPack (const polynomial&, void* outbuf, int outcount,
		      int* position, MPI_Comm comm);
  friend int mpiUnpack (void* inbuf, int insize, int* position, 
			polynomial*, MPI_Comm comm);
#endif

};

class psrephem;

class polyco {

 protected:
  static string anyPsr;
  static MJD    today;

 public:
  static int verbose;

  vector<polynomial> pollys;
  // null initializer
  polyco();                    
  polyco(const polyco &);

  // Load in polycos
  polyco(const char * id);
  polyco(const string id);
  polyco & operator= (const polyco &);

  ~polyco(){};

  // these functions return the number of polynomials successfully loaded
  int load   (const string filename, size_t nbytes=0);
  int load   (const char* filename, size_t nbytes=0);
  int load   (istream &istr, size_t nbytes=0);
  int load   (FILE * fp, size_t nbytes=0);
  int load   (string* instr);

  // these functions return -1 upon error
  int unload (const string filename) const ;
  int unload (const char* filename) const ;

  // these functions return the number of bytes unloaded (-1 on error)
  int unload (string *outstr) const;
  int unload (ostream &ostr) const;
  int unload (FILE* fptr) const;

  void  prettyprint  () const;
  const polynomial* nearest (const MJD &t, 
			     const string& psrname = anyPsr) const;

  const polynomial& best (const MJD &t, 
			  const string& psrname = anyPsr) const;

  int i_nearest (const MJD &t, const string& psrname = anyPsr) const;

  double doppler_shift (const MJD& t, const string& psr = anyPsr) const
    { return best(t, psr).get_doppler_shift(); };

  Phase phase (const MJD& t, const string& psr = anyPsr) const
    { return best(t, psr).phase(t); };

  Phase phase (const MJD& t, float obs_freq, const string& psr = anyPsr) const
    { return best(t, psr).phase(t, obs_freq); };

  double period(const MJD& t, const string& psr = anyPsr) const
    { return best(t, psr).period(t); };

  double frequency(const MJD& t, const string& psr = anyPsr) const
    { return best(t, psr).frequency(t); };

  // bool   is_tempov11   () const { return pollys.front().is_tempov11(); };
  int    get_telescope () const { return pollys.front().get_telescope(); };
  double get_freq      () const { return pollys.front().get_freq(); };
  MJD    get_reftime   () const { return pollys.front().get_reftime(); };
  double get_nspan     () const { return pollys.front().get_nspan(); };
  float  get_dm        () const { return pollys.front().get_dm(); };
  int    get_ncoeff    () const { return pollys.front().get_ncoeff(); };


  bool is_tempov11() const;

  MJD  start_time () const { return pollys.front().start_time(); };
  MJD  end_time ()   const { return pollys.back().end_time(); };

  friend int operator == (const polyco &, const polyco &);
  friend int operator != (const polyco &, const polyco &);

  // returns a polyco valid over the range in MJD specified by m1 and m2
  friend polyco tempoz (const psrephem& eph,
			const MJD& m1=today, const MJD& m2=today, 
			double nspan=960, int ncoeff=12, int maxha=8, 
			int tel=7, double centrefreq=1400.0);

  friend  int tempoz (polyco* poly, const psrephem& eph,
		      const MJD& m1=today, const MJD& m2=today, 
		      double nspan=960, int ncoeff=12, int maxha=8, 
		      int tel=7, double centrefreq=1400.0);

  friend polyco span_poly(const polyco & first_poly, const polyco & second_poly, 
			  const psrephem & pephem);

#ifdef MPI
  friend int mpiPack_size (const polyco&, MPI_Comm comm, int* size);
  friend int mpiPack   (const polyco&, void* outbuf, int outcount,
			int* position, MPI_Comm comm);
  friend int mpiUnpack (void* inbuf, int insize, int* position, 
			polyco*, MPI_Comm comm);
#endif

};

#endif

