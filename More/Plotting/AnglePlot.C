/***************************************************************************
 *
 *   Copyright (C) 2006 by Willem van Straten
 *   Licensed under the Academic Free License version 2.1
 *
 ***************************************************************************/
#include "Pulsar/AnglePlot.h"
#include "Pulsar/AnglePlot.h"

#include "Pulsar/Archive.h"
#include "Pulsar/Integration.h"
#include "Pulsar/PolnProfile.h"

#include <cpgplot.h>
#include <algorithm>

Pulsar::AnglePlot::AnglePlot()
{
  error_bars = true;
  threshold = 4.0;
  span = 0.0;

  isubint = 0;
  ichan = 0;
}

TextInterface::Class* Pulsar::AnglePlot::get_interface ()
{
  return new Interface (this);
}

void Pulsar::AnglePlot::prepare (const Archive* data)
{
  get_angles (data);

  if (angles.size() != data->get_nbin())
    throw Error (InvalidState, "Pulsar::AnglePlot::prepare",
                 "angles vector size=%u != nbin=%u",
                 angles.size(), data->get_nbin());

  float min = 0;
  float max = 0;

  if (span)
  {
    // keep pgplot from drawing the 90 or 180 at the edge
    float half = 0.5 * span - 0.0001;
    min = -half;
    max = half;
  }
  else
  {
    unsigned i_min, i_max;
    get_scale()->get_range (data, i_min, i_max);

    min = min_element(angles.begin()+i_min, angles.begin()+i_max)->val;
    max = max_element(angles.begin()+i_min, angles.begin()+i_max)->val;
  }

  get_frame()->get_y_scale()->set_minmax (min, max);
}

void Pulsar::AnglePlot::draw (const Archive *data)
{
  std::vector<float> phases;
  get_scale()->get_ordinates (data, phases);

  // Added by DS, draw the angles repeatedly over the zoom range given
  float sx, ex;
  get_frame()->get_x_scale()->get_range( sx, ex );

  for( int xoff = int(sx)-1; xoff < int(ex)+1; xoff ++ )
  {
    float offset = 0;
    unsigned times = 1;

    if (span)
    {
      offset = -span;
      times = 3;
    }
    
    for (unsigned ioff=0; ioff < times; ioff++)
    {

      for (unsigned ibin=0; ibin < phases.size(); ibin++)
        if (angles[ibin].get_variance() != 0)
          if (error_bars)
            cpgerr1 (6, phases[ibin]+xoff, angles[ibin].get_value() + offset,
                     angles[ibin].get_error(), 1.0);
          else
            cpgpt1 (phases[ibin]+xoff, angles[ibin].get_value() + offset, 17);

      offset += span;
    }
  }

#if 0
  if (degrees)
  {
    float half_range = (max_phase - min_phase) * 180;
    cpgswin (-half_range, +half_range, -pa_range, pa_range + plus_half);
  }

  if (publn)
    cpgbox("bcst",0,0,"bcnst",60,6);
  else
    cpgbox("bcst",0,0,"bcnvst",30,3);
#endif
}

//! Return the label for the y-axis
std::string Pulsar::AnglePlot::get_flux_label (const Archive* data)
{
  return "P.A. (deg.)";
}
