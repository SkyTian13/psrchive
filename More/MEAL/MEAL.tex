\documentclass[12pt]{article}
\usepackage{psfig}
\usepackage{fullpage}

% bold math italic font
\newcommand{\mbf}[1]{\mbox{\boldmath $#1$}}

% symbol used for sqrt(-1)
\newcommand{\Ci}{\ensuremath{i}}

\newcommand{\var}{{\rm var}}
\newcommand{\trace}{{\rm tr}}

\newcommand{\Rotation}{{\bf R}}
\newcommand{\Boost}{{\bf B}}

\newcommand{\vRotation}[1][n]{\ensuremath{\Rotation_{\mbfs{\hat #1}}}}
\newcommand{\vBoost}[1][m]{\ensuremath{\Boost_{\mbfs{\hat #1}}}}

\newcommand{\rotat}{\ensuremath{\vRotation(\phi)}}
\newcommand{\boost}{\ensuremath{\vBoost(\beta)}}

\newcommand{\pauli}[1]{\ensuremath{ {\mbf{\sigma}}_{#1} }}

\begin{document}

\section{Introduction}

This is a quick reference for the Measurement and Error Analysis
Library (MEAL), as defined within the {\tt MEAL} namespace.  These
classes implement a general-purpose library for performing non-linear
least-squares and error propagation.

\section{Function Behaviours}

All mathematical expressions are derived from the {\tt Function} base
class.  A {\tt Function} may have an arbitrary number of variables;
however, a distinction is made between parameters, ${\mbf a}=(a_0,
a_1, ... , a_N)$ and independent variables, or arguments, ${\mbf
x}=(x_0, x_1, ... , x_M)$.  Each {\tt Function} class defines an
evaluation method that returns a result, $M({\mbf x},{\mbf a})$, and
the partial derivatives of this result with respect to each of the
parameters, $\partial M/\partial a_i$.

Functionality is organized into three behaviours: parameter, argument,
and evaluation.  These behaviours are represented by three base
classes, each of which virtually inherits the {\tt Function} base
class.  As each behaviour is mutually exclusive, derived classes can
incorporate pre-defined behaviours by multiple inheritance.

\subsection{Parameter Behaviour}

A {\tt Function} may have an arbitary number of parameters,
$\mbf{a}=(a_0, a_1, ... , a_N)$.  The type of each parameter must be a
scalar, and the {\tt Function} class currently implements
double-precision floating point parameters.  Each parameter has an
associated name, estimated variance, and a flag that indicates if the
parameter is free or fixed.  The classes that implement the parameter
management interface inherit the {\tt ParameterBehaviour} base class.

\subsection{Argument Behaviour}

A {\tt Function} may be further parameterized by an arbitrary number of
independent variables, or arguments, ${\mbf x}=(x_0, x_1, ... , x_M)$.
Unlike parameters, arguments have no specified type, no estimated
variance, and can never be free.  Because they have no specified type,
the interface between a {\tt Function} and its arguments is mediated
through the {\tt Argument} and {\tt Argument::Value} abstract base
classes.  Classes that may be parameterized by additional arguments
inherit the {\tt ArgumentBehaviour} base class.

\subsection{Evaluation Behaviour}

The return type of a {\tt Function} is also unspecified in the base
class.  Therefore, derived classes must inherit one of the children of
the {\tt EvaluationBehaviour} base class.  There are currently two
classes of children:
\begin{itemize}
\item {\tt Scalar} - returns a scalar value
\item {\tt Complex2} - returns a complex $2\times2$ matrix
\end{itemize}
A number of evaluation behaviours have been implemented as
templates, or Rules.

\section{Modular Construction}

TO DO: Show how new functions can be built up from more basic elements.

\section{Example Usage}

\subsection{Non-linear Least-Squares Estimation}

TO DO: Document lmfit

\subsection{Error Propagation}

The {\tt Estimate} template class is very useful for storing a value
and its estimated variance.  There are also operators and functions
which enable the propagation of error estimates to derived quantities;
for example:
\begin{verbatim}
Estimate<float> y (0.596,0.0034);
Estimate<float> x (-0.83,0.0072);
Estimate<float> z = pow (y,x);
\end{verbatim}
automatically computes the variance of the new variable, {\tt z}.
However, the {\tt Estimate} template class fails when a variable
appears more than once in an expression; e.g.
\begin{verbatim}
Estimate<float> ratio = x/x;
\end{verbatim}
should yield $1\pm0$; however, the {\tt Estimate} template class does
not recognize that the numerator and denominator are the same
variable, and incorrectly sums the weighted variances.

The problem of correctly computing the partial derivatives of an
expression with respect to its variables makes use of the exact same
functionality used to generate the gradient and Hessian matrix in
non-linear least squares fitting.

A simplified interface to this functionality is implemented by the
{\tt ScalarMath} class.  {\tt ScalarMath} objects may be conveniently
initialized as a single parameter and its estimated variance using the
{\tt Estimate} template class.  As with float and double types, {\tt
ScalarMath} objects may be combined using normal arithmetic operations
and basic mathematical functions, creating {\tt Scalar} functions of
any number of parameters.  For example:
\begin{verbatim}
  MEAL::ScalarMath x (Estimate<double> (0.9587, 0.00058));
  MEAL::ScalarMath y (Estimate<double> (-0.283, 0.00034));
  cerr << "Polar angle = " << atan2 (y, x) << endl;
\end{verbatim}
yields the output
\begin{verbatim}
  Polar angle = (-0.287039 +/- 0.0189612)
\end{verbatim}
\newpage
\noindent
As with any native type, the {\tt ScalarMath} class can be used as a
template argument, e.g.
\begin{verbatim}
  complex<MEAL::ScalarMath> z (Estimate<double> (0.87, 0.0041),
                               Estimate<double> (2.38, 0.0095));

  complex<MEAL::ScalarMath> w (Estimate<double> (1.74, 0.0081),
                               Estimate<double> (-.63, 0.0043));

  Jones<MEAL::ScalarMath> jones (z, conj(z),
                                 conj(w), w);
\end{verbatim}
enabling error propagation through increasingly complex expressions.

\end{document}

